# 1.基础知识
随着应用的扩展，您可能会发现有必要从服务器获取数据、与设备的传感器进行交互、访问本地存储或呈现复杂的界面。应用的多功能性需要全面的测试策略。

## 1.1根据执行环境组织整理测试目录
Android Studio 中的典型项目包含两个用于放置测试的目录。请按以下方式组织整理您的测试：

androidTest 目录应包含在真实或虚拟设备上运行的测试。此类测试包括集成测试、端到端测试，以及仅靠 JVM 无法完成应用功能验证的其他测试。
test 目录应包含在本地计算机上运行的测试，如单元测试。
考虑在不同类型的设备上运行测试的利弊
在设备上运行测试时，您可以从以下类型中进行选择：

真实设备
虚拟设备（如 Android Studio 中的模拟器）
模拟设备（如 Robolectric）
真实设备可提供最高的保真度，但运行测试所花费的时间也最多。另一方面，模拟设备可提供较高的测试速度，但代价是保真度较低。不过，平台在二进制资源和逼真的循环程序上的改进使得模拟设备能够产生更逼真的结果。
虚拟设备则平衡了保真度和速度。当您使用虚拟设备进行测试时，可以使用快照来最大限度地缩短测试之间的设置时间。

## 1.2 测试金字塔的级别
包含三层的金字塔
图 2. 测试金字塔，显示了应用的测试套件应包含的三类测试
测试金字塔（如图 2 所示）说明了应用应如何包含三类测试（即小型、中型和大型测试）：

- 小型测试是指单元测试，用于验证应用的行为，一次验证一个类。
- 中型测试是指集成测试，用于验证模块内堆栈级别之间的互动或相关模块之间的互动。
- 大型测试是指端到端测试，用于验证跨越了应用的多个模块的用户操作流程。
沿着金字塔逐级向上，从小型测试到大型测试，各类测试的保真度逐级提高，但维护和调试工作所需的执行时间和工作量也逐级增加。因此，您编写的单元测试应多于集成测试，集成测试应多于端到端测试。虽然各类测试的比例可能会因应用的用例不同而异，但我们通常建议各类测试所占比例如下：小型测试占 70%，中型测试占 20%，大型测试占 10%

编写小型测试
您编写的小型测试应该是高度集中的单元测试，能够详尽地验证应用中每个类的功能和约定。

在特定类中添加和更改方法时，请针对它们创建和运行单元测试。如果这些测试依赖于 Android 框架，请使用与设备无关的统一 API，如 androidx.test API。这种一致性可让您在本地运行测试，而无需使用物理设备或模拟器。

如果您的测试依赖于资源，请在 应用的 build.gradle 文件中启用 includeAndroidResources 选项。然后，您的单元测试可以访问编译版本的资源，从而使测试更快速且更准确地运行。

app/build.gradle
`
android {
// ...

        testOptions {
            unitTests {
                includeAndroidResources = true
            }
        }
    }

`
## 1.2 本地单元测试
尽可能使用 AndroidX Test API，以便您的单元测试可以在设备或模拟器上运行。对于始终在由 JVM 驱动的开发计算机上运行的测试，您可以使用 Robolectric。

Robolectric 会模拟 Android 4.1（API 级别 16）或更高版本的运行时环境，并提供由社区维护的虚假对象（称为“影子”）。通过此功能，您可以测试依赖于框架的代码，而无需使用模拟器或模拟对象。Robolectric 支持 Android 平台的以下几个方面：

组件生命周期
事件循环
所有资源

## 1.3 插桩单元测试
您可以在物理设备或模拟器上运行插桩单元测试。不过，这种形式的测试所用的执行时间明显多于本地单元测试，因此，最好只有在必须根据实际设备硬件评估应用的行为时才依靠此方法。

运行插桩测试时，AndroidX Test 会使用以下线程：

主线程，也称为“界面线程”或“Activity 线程”，界面交互和 Activity 生命周期事件发生在此线程上。
插桩线程，大多数测试都在此线程上运行。当您的测试套件开始时，AndroidJUnitTest 类将启动此线程。
如果您需要在主线程上执行某个测试，请使用 @UiThreadTest 注释该测试。

## 1.4 编写中型测试
除了通过运行小型测试来测试应用的每个单元之外，您还应从模块级别验证应用的行为。为此，请编写中型测试，即用于验证一组单元的协作和交互的集成测试。

您可以根据应用的结构和以下中型测试示例（按范围递增的顺序）来定义表示应用中的单元组的最佳方式：

视图和视图模型之间的互动，如测试 Fragment 对象、验证布局 XML 或评估 ViewModel 对象的数据绑定逻辑。
应用的代码库层中的测试，验证不同数据源和数据访问对象 (DAO) 是否按预期进行互动。
应用的垂直切片，测试特定屏幕上的互动。此类测试目的在于验证应用堆栈的所有各层的互动。
多 Fragment 测试，评估应用的特定区域。与本列表中提到的其他类型的中型测试不同，这种类型的测试通常需要真实设备，因为被测互动涉及多个界面元素。
如需执行这些测试，请执行以下操作：

使用 Espresso-Intents 库中的方法。如需简化传入这些测试的信息，请使用虚假对象和打桩。
结合使用 IntentSubject 和基于 Truth 的断言来验证捕获的 intent。

## 1.5 运行插桩中型测试时使用 Espresso
当您在设备或 Robolectric 上执行类似于下面的界面互动时，Espresso 有助于使任务保持同步：

对 View 对象执行操作。
评估具有无障碍功能需求的用户如何使用您的应用。
找到并激活 RecyclerView 和 AdapterView 对象中的项。
验证传出 intent 的状态。
验证 WebView 对象中 DOM 的结构。
如需详细了解这些互动以及如何在应用的测试中使用它们，请参阅 Espresso 指南。
## 1.6 编写大型测试

尽管单独测试应用中的每个类和模块很重要，但验证可引导用户使用多个模块和功能的端到端工作流也同样重要。这些类型的测试会在您的代码中形成不可避免的瓶颈，但您可以通过验证尽可能接近实际成品的应用来最大限度地减轻这种影响。

Espresso 中的同步支持
除了支持中型插桩测试之外，Espresso 还支持在大型测试中完成以下任务时实现同步：

完成跨应用的进程界限的工作流。仅适用于 Android 8.0（API 级别 26）及更高版本。
跟踪应用中长时间运行的后台操作。
执行设备外测试。
如需详细了解这些互动以及如何在应用的测试中使用它们，请参阅 Espresso 指南。


使用 AndroidX Test 完成其他测试任务
本部分介绍如何使用 AndroidX Test 的元素来进一步优化应用的测试。

使用 Truth 创建更容易读懂的断言
Guava 团队提供了一个名为 Truth 的流利断言库。在构建测试的验证步骤（或 then 步骤）时，您可以使用此库来代替基于 JUnit 或 Hamcrest 的断言。

通常，您可以使用 Truth 来表达某个对象具有特定属性，使用的短语包含您要测试的条件，例如：

assertThat(object).hasFlags(FLAGS)
assertThat(object).doesNotHaveFlags(FLAGS)
assertThat(intent).hasData(URI)
assertThat(extras).string(string_key).equals(EXPECTED)
AndroidX Test 支持 Android 的其他几个主题，以使基于 Truth 的断言更易于构建：

BundleSubject
IntentSubject
MotionEventSubject
NotificationActionSubject
NotificationSubject
PendingIntentSubject
PointerCoordsSubject
PointerPropertiesSubject
AndroidX Test API 可帮助您执行与移动应用测

